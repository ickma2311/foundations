# 5.1 Permutation Matrices

## Definition

A matrix is a **permutation matrix** if:
- Each row has exactly one 1, all other entries are 0
- Each column has exactly one 1, all other entries are 0

### Example: Basic Permutation Matrix

```python
import numpy as np

# Create a random 3x4 matrix
A = np.random.randint(0, 10, (3, 4))
print("Matrix A:")
print(A)

# Create a permutation matrix that swaps rows 0 and 1
P = np.zeros((3, 3)).astype(int)
P[0, 1] = 1
P[1, 0] = 1
P[2, 2] = 1
print("\nPermutation matrix P:")
print(P)

# Apply permutation: PA swaps rows 0 and 1 of A
print("\nP @ A (rows 0 and 1 swapped):")
print(P @ A)
```

**Explanation:**
- Creates a 3×4 matrix A with random integers
- Creates a 3×3 permutation matrix P that swaps rows 0 and 1
- Matrix multiplication `P @ A` applies the row permutation to A

## Number of Permutation Matrices

A matrix with **n rows** has **n! permutation matrices**

**Examples:**
- n=3: 3! = 6 permutation matrices
- n=4: 4! = 24 permutation matrices
- n=5: 5! = 120 permutation matrices

### Generating All Permutation Matrices

```python
from itertools import permutations

# Generate all permutations for n=3
n = 3
perms = list(permutations(range(n)))
print(f"There are {len(perms)} permutation matrices for n={n}")

# Display all permutation matrices and their effect on A
for perm in perms:
    print(f"Permutation: {perm}")
    P = np.zeros((n, n)).astype(int)
    P[np.arange(n), perm] = 1
    print("Permutation matrix P:")
    print(P)
    print("P @ A:")
    print(P @ A)
    print()
```

**Explanation:**
- Uses `itertools.permutations()` to generate all possible permutations of row indices
- For n=3, creates all 6 permutation matrices: (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)
- Each permutation matrix reorders the rows of A differently

### Example Permutation Matrices for n=3

**Identity (no permutation):**
```
P = [1 0 0]
    [0 1 0]
    [0 0 1]
```

**Swap rows 0 and 1:**
```
P = [0 1 0]
    [1 0 0]
    [0 0 1]
```

**Cyclic permutation:**
```
P = [0 1 0]
    [0 0 1]
    [1 0 0]
```

---

## Properties of Permutation Matrices

**Key Properties:**

1. **$P^{-1} = P^T$** (inverse equals transpose)
2. **$PP^T = P^TP = I$** (orthogonal matrix)
3. **$\det(P) = \pm 1$** (determinant is ±1)

---

## Proof 1: $P^{-1} = P^T$

### Strategy

Given that $PP^{-1} = I$ by definition of inverse,
We only need to prove that $PP^T = I$
Then we can conclude that $P^{-1} = P^T$

### Proof of $PP^T = I$

```python
import numpy as np

# Example permutation matrix (swaps rows 0 and 1)
P = np.array([[0, 1, 0],
              [1, 0, 0],
              [0, 0, 1]])

# Compute transpose
P_T = P.T

# Verify PP^T = I
result = P @ P_T
print("P @ P^T =")
print(result)
```

**Result:** Identity matrix $I$

**Explanation:**

The $n$-th column of $P^T$ is the $n$-th row of $P$.

When computing $PP^T$:
- The $(i,j)$ entry of $PP^T$ is the dot product of row $i$ of $P$ with column $j$ of $P^T$
- This equals the dot product of row $i$ of $P$ with row $j$ of $P$
- When $i = j$: dot product of a row with itself = 1 (each row has exactly one 1)
- When $i \neq j$: dot product of different rows = 0 (the 1's are in different positions)

Therefore, $PP^T = I$

### Verification by Row

```python
# Verify by computing each row of P times P^T
print("Row 0 of P times P^T:", P[0] @ P_T)
print("Row 1 of P times P^T:", P[1] @ P_T)
print("Row 2 of P times P^T:", P[2] @ P_T)
print("\nEach row gives one row of the identity matrix!")
```

### Conclusion: $P^{-1} = P^T$

**Proof:**
$$
\begin{align}
PP^T &= I \quad \text{(proved above)} \\
PP^{-1} &= I \quad \text{(definition of inverse)} \\
\therefore P^{-1} &= P^T
\end{align}
$$

This is a remarkable property: **the inverse of a permutation matrix equals its transpose!**

**Practical Implications:**
- Computing $P^{-1}$ is as simple as transposing $P$
- Transposition is $O(n^2)$, much faster than general matrix inversion
- If $PA$ permutes rows, then $P^T(PA) = A$ undoes the permutation

---

## Proof 2: $\det(P) = \pm 1$

### Properties of Determinants

**Properties used in the proof:**
1. $\det(AB) = \det(A)\det(B)$ (product property)
2. $\det(A^T) = \det(A)$ (transpose property)

### Proof

$$
\begin{align}
\det(PP^T) &= \det(I) = 1 \\
\det(PP^T) &= \det(P)\det(P^T) \\
&= \det(P)\det(P) \\
&= \det(P)^2 \\
\therefore \det(P)^2 &= 1 \\
\det(P) &= \pm 1
\end{align}
$$

### Interpretation

- **$\det(P) = +1$**: even permutation (even number of row swaps)
- **$\det(P) = -1$**: odd permutation (odd number of row swaps)

**Examples:**
- Identity matrix: $\det(I) = +1$ (zero swaps)
- Single swap: $\det(P) = -1$ (one swap)
- Two swaps: $\det(P) = +1$ (two swaps)

---

## Applications in Linear Algebra

### LU Decomposition with Pivoting

Permutation matrices are essential for:
- **Partial pivoting**: $PA = LU$ where $P$ reorders rows to avoid division by small pivots
- **Numerical stability**: Strategic row exchanges improve computational accuracy
- **Complete pivoting**: Both row and column permutations for maximum stability

### Matrix Operations

- **Row reordering**: Left multiplication $PA$ reorders rows of $A$
- **Column reordering**: Right multiplication $AP$ reorders columns of $A$
- **Similarity transformations**: $PAP^T$ performs symmetric permutation

### Computational Efficiency

- Computing inverse: $P^{-1} = P^T$ is instant
- Solving $Px = b$: multiply by $P^T$ instead of traditional solving
- Checking invertibility: all permutation matrices are invertible

---

## Summary

**Permutation Matrices:**
- Special structure: one 1 per row/column
- Total count: $n!$ for $n \times n$ matrices
- Always invertible with $P^{-1} = P^T$
- Determinant always $\pm 1$
- Essential for numerical linear algebra algorithms

**Key Insight:** Permutation matrices are orthogonal matrices with a very special structure, making them computationally efficient and theoretically important.

---

*Source: MIT 18.06SC Linear Algebra, Lecture 5*
